Изначально в методе Squirrel я получал первую цифру факториала путём преобразования его в строку, извлечения первого символа и обратного преобразования в целочисленный тип. Сейчас получение первой цифры факториала происходит благодаря циклу деления числа на 10 определенное количество раз. Это позволило избавиться от двух изменений типа данных.

Изначально в методе PatternUnlock преобразовывал длину итоговой последовательности из вещественного числа в строку и преобразовывал её. Это влекло за собой ошибку с интерпретацией значений после разделителя ('.' и ',' в разно настроенных системах). Избавился от этой проблемы умножением на 10'000, математическим округлением и дальшнейшем преобразованием строки встроенными методами языка.

В методе ConquestCampaign добавил логические переменные isConquered = battlefield[i][j] == 1 (обозначает что поле завоевано) и isForAttack = battlefield[i][j] == 2 (обозначает что поле должно быть атаковано). Переменные добавлены для улучшения читаемости кода.

В методе PatternUnlock добавил логическую переменную isDiagonal = (sumOfBesideDigits == 6 || sumOfBesideDigits == 8) || ((sumOfBesideDigits == 9 || sumOfBesideDigits == 11) && (hits[i] >= 7 || hits[i - 1] >= 7)), обозначающую диагональ при подсчете длины линии для улучшения читаемости кода.

В методе Unmanned добавил три переменных timeToReach, redLightTime и redLightTime, которые хранят данные из массива. Читаемость кода значительно улучшилась.

В методе LineAnalysis добавил логическую переменную isPattern, для обозначения, является ли часть строки искомым паттерном, для улучшения читаемости кода. Также добавил константу CONTROL_CHARACTER = '*' для анализа последовательностей.

В методе ShopOLAP избавился от магической строки посредством ввода константы EMPTY_STRING, которая означает пустую строку. Константа используется несколько раз.

В методе TreeOfLife добавил логическую переменную isBranch = treeState[i][j] != 0, избавившись от "магического" нуля, которая проверяет является ли поле веткой или нет.

Добавил логическую переменную isPair = (s.charAt(i) == ')' && stack.peek() == '(') || (s.charAt(i) == '}' && stack.peek() == '{') || (s.charAt(i) == ']' && stack.peek() == '['), проверяющую, образуют ли символы пару.

Добавил в метод WordSearch логическую переменную isSubstring = (start + len == s1.length()) || (start + len < s1.length() && (s1.charAt(start + len) == ' ' || s1.charAt(start + len) == '.')), котрая значительно упрощает чтение кода в условном операторе

В метод SumOfThe добавил логическую переменную notTheSameNumber = j != i; для лучшей читаемости кода.

В методе MassVote добавил проверку не является ли переменная totalNumberOfVotes нулём перед вычислением процентов. 

Перед стандарным строковым методом split() теперь добавляю константу перед ним вида SEPARATOR = ' '.

P.S. В плане преобразований типов или некорректных сравнений очень помогает линтер, достаточно жёстко настроенный.

